#!/usr/bin/env node

/**
 * Skrypt do uploadowania podzielonych danych inwestycyjnych do Firebase
 * Kompatybilny z modelami Flutter: Bond, Share, Loan
 */

const admin = require('firebase-admin');
const fs = require('fs');
const path = require('path');

// Inicjalizacja Firebase Admin SDK
function initializeFirebase() {
  if (!admin.apps.length) {
    try {
      const serviceAccount = require('../service-account.json');
      admin.initializeApp({
        credential: admin.credential.cert(serviceAccount),
        databaseURL: 'https://your-project-id.firebaseio.com' // Zmie≈Ñ na swojƒÖ bazƒô
      });
      console.log('üî• Firebase initialized successfully');
    } catch (error) {
      console.error('‚ùå Firebase initialization failed:', error.message);
      process.exit(1);
    }
  }
}

// Kolekcje Firebase zgodne z architekturƒÖ projektu
const COLLECTIONS = {
  bonds: 'bonds',
  shares: 'shares',
  loans: 'loans',
  apartments: 'apartments',
  clients: 'clients',
  investments: 'investments'
};

const INPUT_DIR = process.argv[2] || 'split_investment_data';

class FirebaseUploader {
  constructor() {
    this.db = admin.firestore();
    this.batchSize = 500; // Firebase batch limit
  }

  // Sprawd≈∫ czy pliki wej≈õciowe istniejƒÖ
  checkInputFiles() {
    const requiredFiles = ['bonds.json', 'shares.json', 'loans.json', 'apartments.json', 'clients.json', 'metadata.json'];
    const missingFiles = [];

    for (const file of requiredFiles) {
      const filePath = path.join(INPUT_DIR, file);
      if (!fs.existsSync(filePath)) {
        missingFiles.push(file);
      }
    }

    if (missingFiles.length > 0 && missingFiles.length < 6) {
      console.log(`‚ö†Ô∏è  Uwaga: Nie znaleziono plik√≥w: ${missingFiles.join(', ')}`);
    } else if (missingFiles.length === 6) {
      console.error(`‚ùå Katalog ${INPUT_DIR} nie zawiera plik√≥w danych`);
      console.log('Uruchom najpierw: node split_json_by_investment_type_complete.js <plik.json>');
      process.exit(1);
    }
  }

  // Upload danych w batches
  async uploadInBatches(collectionName, data) {
    const totalRecords = data.length;
    let uploadedCount = 0;

    console.log(`üì§ Uploadowanie ${totalRecords} rekord√≥w do kolekcji: ${collectionName}`);

    for (let i = 0; i < data.length; i += this.batchSize) {
      const batch = this.db.batch();
      const chunk = data.slice(i, i + this.batchSize);

      chunk.forEach((item) => {
        // Usu≈Ñ pole 'id' z danych - Firestore sam wygeneruje ID dokumentu
        const { id, ...itemData } = item;
        const docRef = this.db.collection(collectionName).doc();
        batch.set(docRef, itemData);
      });

      try {
        await batch.commit();
        uploadedCount += chunk.length;

        const progress = ((uploadedCount / totalRecords) * 100).toFixed(1);
        console.log(`  ‚úÖ ${uploadedCount}/${totalRecords} (${progress}%)`);

      } catch (error) {
        console.error(`‚ùå B≈ÇƒÖd podczas uploadowania batcha ${i}-${i + chunk.length}:`, error.message);
        throw error;
      }
    }

    return uploadedCount;
  }

  // Upload obligacji
  async uploadBonds() {
    const filePath = path.join(INPUT_DIR, 'bonds.json');
    if (!fs.existsSync(filePath)) {
      console.log('‚è≠Ô∏è  Pomijam obligacje - plik bonds.json nie istnieje');
      return 0;
    }

    try {
      const bondsData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      return await this.uploadInBatches(COLLECTIONS.bonds, bondsData);
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd podczas uploadowania obligacji:', error.message);
      throw error;
    }
  }

  // Upload udzia≈Ç√≥w
  async uploadShares() {
    const filePath = path.join(INPUT_DIR, 'shares.json');
    if (!fs.existsSync(filePath)) {
      console.log('‚è≠Ô∏è  Pomijam udzia≈Çy - plik shares.json nie istnieje');
      return 0;
    }

    try {
      const sharesData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      return await this.uploadInBatches(COLLECTIONS.shares, sharesData);
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd podczas uploadowania udzia≈Ç√≥w:', error.message);
      throw error;
    }
  }

  // Upload po≈ºyczek
  async uploadLoans() {
    const filePath = path.join(INPUT_DIR, 'loans.json');
    if (!fs.existsSync(filePath)) {
      console.log('‚è≠Ô∏è  Pomijam po≈ºyczki - plik loans.json nie istnieje');
      return 0;
    }

    try {
      const loansData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      return await this.uploadInBatches(COLLECTIONS.loans, loansData);
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd podczas uploadowania po≈ºyczek:', error.message);
      throw error;
    }
  }

  // Upload apartament√≥w
  async uploadApartments() {
    const filePath = path.join(INPUT_DIR, 'apartments.json');
    if (!fs.existsSync(filePath)) {
      console.log('‚è≠Ô∏è  Pomijam apartamenty - plik apartments.json nie istnieje');
      return 0;
    }

    try {
      const apartmentsData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      return await this.uploadInBatches(COLLECTIONS.apartments, apartmentsData);
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd podczas uploadowania apartament√≥w:', error.message);
      throw error;
    }
  }

  // Upload klient√≥w
  async uploadClients() {
    const filePath = path.join(INPUT_DIR, 'clients.json');
    if (!fs.existsSync(filePath)) {
      console.log('‚è≠Ô∏è  Pomijam klient√≥w - plik clients.json nie istnieje');
      return 0;
    }

    try {
      const clientsData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      return await this.uploadInBatches(COLLECTIONS.clients, clientsData);
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd podczas uploadowania klient√≥w:', error.message);
      throw error;
    }
  }

  // Stw√≥rz zbiorczƒÖ kolekcjƒô investments (opcjonalne)
  async createUnifiedInvestments() {
    console.log('üîÑ Tworzenie zbiorczo kolekcji investments...');

    const files = ['bonds.json', 'shares.json', 'loans.json', 'apartments.json'];
    const allInvestments = [];

    for (const file of files) {
      const filePath = path.join(INPUT_DIR, file);
      if (fs.existsSync(filePath)) {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));

        // Dodaj type field dla ka≈ºdego rekordu
        const typeFromFile = file.replace('.json', '');
        const investmentsWithType = data.map(item => ({
          ...item,
          investment_type: typeFromFile,
          // Mapuj na schemat Investment model
          remainingCapital: item.kapital_pozostaly || item.kwota_inwestycji || 0,
          investmentAmount: item.kwota_inwestycji || 0,
          realizedCapital: item.kapital_zrealizowany || 0,
          realizedInterest: item.odsetki_zrealizowane || 0,
          remainingInterest: item.odsetki_pozostale || 0,
          productType: item.typ_produktu || typeFromFile,
          createdAt: item.created_at,
          updatedAt: item.uploaded_at || item.created_at
        }));

        allInvestments.push(...investmentsWithType);
      }
    }

    if (allInvestments.length > 0) {
      return await this.uploadInBatches(COLLECTIONS.investments, allInvestments);
    }

    return 0;
  }

  // Wyczy≈õƒá kolekcje (u≈ºyj ostro≈ºnie!)
  async clearCollection(collectionName) {
    console.log(`üóëÔ∏è  Czyszczenie kolekcji: ${collectionName}`);

    const collectionRef = this.db.collection(collectionName);
    const snapshot = await collectionRef.get();

    if (snapshot.empty) {
      console.log(`  ‚úÖ Kolekcja ${collectionName} jest ju≈º pusta`);
      return;
    }

    const batch = this.db.batch();
    snapshot.docs.forEach(doc => batch.delete(doc.ref));

    await batch.commit();
    console.log(`  ‚úÖ Usuniƒôto ${snapshot.docs.length} dokument√≥w z kolekcji ${collectionName}`);
  }

  // G≈Ç√≥wny proces uploadowania
  async uploadAll(clearFirst = false) {
    try {
      const startTime = Date.now();
      let totalUploaded = 0;

      console.log(`üöÄ Rozpoczynanie uploadowania danych z katalogu: ${INPUT_DIR}`);

      if (clearFirst) {
        console.log('‚ö†Ô∏è  Czyszczenie istniejƒÖcych danych...');
        await Promise.all([
          this.clearCollection(COLLECTIONS.bonds),
          this.clearCollection(COLLECTIONS.shares),
          this.clearCollection(COLLECTIONS.loans),
          this.clearCollection(COLLECTIONS.investments)
        ]);
      }

      // Upload ka≈ºdego typu
      const bondsCount = await this.uploadBonds();
      const sharesCount = await this.uploadShares();
      const loansCount = await this.uploadLoans();
      const apartmentsCount = await this.uploadApartments();
      const clientsCount = await this.uploadClients();
      const investmentsCount = await this.createUnifiedInvestments();

      totalUploaded = bondsCount + sharesCount + loansCount + apartmentsCount + clientsCount; const duration = ((Date.now() - startTime) / 1000).toFixed(2);

      console.log('\nüéâ UPLOAD ZAKO≈ÉCZONY POMY≈öLNIE!');
      console.log(`üìä Statystyki:`);
      console.log(`  Obligacje: ${bondsCount} rekord√≥w`);
      console.log(`  Udzia≈Çy: ${sharesCount} rekord√≥w`);
      console.log(`  Po≈ºyczki: ${loansCount} rekord√≥w`);
      console.log(`  Apartamenty: ${apartmentsCount} rekord√≥w`);
      console.log(`  Klienci: ${clientsCount} rekord√≥w`);
      console.log(`  Zbiorczy investments: ${investmentsCount} rekord√≥w`);
      console.log(`  Ca≈Çkowity czas: ${duration}s`);
      console.log(`  Rekord√≥w na sekundƒô: ${(totalUploaded / parseFloat(duration)).toFixed(1)}`);

      // Zapisz log uploadu
      const uploadLog = {
        uploadedAt: new Date().toISOString(),
        duration: `${duration}s`,
        totalRecords: totalUploaded,
        collections: {
          bonds: bondsCount,
          shares: sharesCount,
          loans: loansCount,
          apartments: apartmentsCount,
          clients: clientsCount,
          investments: investmentsCount
        },
        sourceDirectory: INPUT_DIR
      };

      fs.writeFileSync(
        path.join(INPUT_DIR, 'upload_log.json'),
        JSON.stringify(uploadLog, null, 2)
      );

    } catch (error) {
      console.error('üí• B≈ÇƒÖd krytyczny podczas uploadu:', error.message);
      console.error(error.stack);
      process.exit(1);
    }
  }
}

// Uruchomienie skryptu
async function main() {
  const args = process.argv.slice(2);
  const clearFirst = args.includes('--clear');

  console.log('üîß Firebase Investment Data Uploader');
  console.log('=====================================\n');

  initializeFirebase();

  const uploader = new FirebaseUploader();
  uploader.checkInputFiles();

  if (clearFirst) {
    console.log('‚ö†Ô∏è  UWAGA: Zostanie usuniƒôte wszystkie dane z kolekcji!');
    // W rzeczywistej aplikacji doda≈Çby≈õ tu potwierdzenie
  }

  await uploader.uploadAll(clearFirst);

  console.log('\n‚ú® Zako≈Ñczono pomy≈õlnie!');
  process.exit(0);
}

// Obs≈Çuga b≈Çƒôd√≥w
process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• Nieobs≈Çu≈ºone odrzucenie Promise:', promise, 'pow√≥d:', reason);
  process.exit(1);
});

if (require.main === module) {
  main();
}

module.exports = { FirebaseUploader };
