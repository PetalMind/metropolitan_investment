/**
 * üöÄ OPTYMALIZACJA INWESTOR√ìW PRODUKT√ìW - Firebase Functions
 * Przeniesienie ciƒô≈ºkiej logiki wyszukiwania i grupowania na serwer Google
 * Zastƒôpuje ProductInvestorsService po stronie klienta
 */

const { onCall } = require("firebase-functions/v2/https");
const { HttpsError } = require("firebase-functions/v2/https");
const admin = require("firebase-admin");

// üéØ G≈Å√ìWNA FUNKCJA: Pobieranie inwestor√≥w dla produktu z zaawansowanƒÖ optymalizacjƒÖ
exports.getProductInvestorsOptimized = onCall({
  memory: "2GiB",
  timeoutSeconds: 300,
  region: "europe-west1",
}, async (request) => {
  const data = request.data || {};
  const startTime = Date.now();

  // Inicjalizuj Firestore wewnƒÖtrz funkcji
  const db = admin.firestore();

  console.log("üîç [Product Investors] Rozpoczynam optymalizowane wyszukiwanie...", data);

  try {
    const {
      productName,
      productType, // 'bonds', 'shares', 'loans', 'apartments', 'other'
      searchStrategy = 'comprehensive', // 'exact', 'type', 'comprehensive'
      forceRefresh = false,
    } = data;

    if (!productName && !productType) {
      throw new HttpsError('invalid-argument', 'Wymagana nazwa produktu lub typ produktu');
    }

    // üíæ Cache Key
    const cacheKey = `product_investors_${productName || productType}_${searchStrategy}`;

    if (!forceRefresh) {
      const cached = await getCachedResult(cacheKey);
      if (cached) {
        console.log("‚ö° [Product Investors] Zwracam z cache");
        return {
          ...cached,
          fromCache: true,
          executionTime: Date.now() - startTime
        };
      }
    }

    // üìä KROK 1: R√≥wnoleg≈Çe pobieranie wszystkich potrzebnych danych
    console.log("üìã [Product Investors] Pobieranie danych...");

    // Zmniejsz limity dla test√≥w
    const dataLimit = 1000; // Zamiast 50000
    const clientLimit = 500; // Zamiast 10000

    const [
      investmentsSnapshot,
      bondsSnapshot,
      sharesSnapshot,
      loansSnapshot,
      apartmentsSnapshot,
      clientsSnapshot,
    ] = await Promise.all([
      // Pobierz z g≈Ç√≥wnej kolekcji investments (ograniczony limit)
      db.collection('investments').limit(dataLimit).get(),
      // Pobierz z dedykowanych kolekcji (ograniczone limity)
      db.collection('bonds').limit(dataLimit).get(),
      db.collection('shares').limit(dataLimit).get(),
      db.collection('loans').limit(dataLimit).get(),
      db.collection('apartments').limit(dataLimit).get(),
      // Pobierz klient√≥w (ograniczony limit)
      db.collection('clients').limit(clientLimit).get(),
    ]);

    console.log(`üìä [Product Investors] Pobrane dane:
      - Investments: ${investmentsSnapshot.docs.length}
      - Bonds: ${bondsSnapshot.docs.length}  
      - Shares: ${sharesSnapshot.docs.length}
      - Loans: ${loansSnapshot.docs.length}
      - Apartments: ${apartmentsSnapshot.docs.length}
      - Clients: ${clientsSnapshot.docs.length}`);

    // üìä KROK 2: Przygotuj mapƒô klient√≥w dla szybkiego wyszukiwania
    const clientsMap = new Map();
    const clientsByExcelId = new Map();
    const clientsByName = new Map();

    clientsSnapshot.docs.forEach(doc => {
      const client = { id: doc.id, ...doc.data() };
      clientsMap.set(client.id, client);

      // Mapowanie po excelId dla Excel ID -> Firestore UUID
      if (client.excelId) {
        clientsByExcelId.set(client.excelId.toString(), client);
      }
      if (client.original_id) {
        clientsByExcelId.set(client.original_id.toString(), client);
      }

      // Mapowanie przez stare pole 'id' (numeryczne Excel ID)
      if (client.id && typeof client.id === 'number') {
        clientsByExcelId.set(client.id.toString(), client);
      }

      // Mapowanie po nazwie klienta (fallback)
      const clientName = client.fullName || client.imie_nazwisko || client.name;
      if (clientName) {
        clientsByName.set(clientName, client);
      }
    });

    console.log(`üë• [Product Investors] Utworzono mapowania:
      - UUID: ${clientsMap.size}
      - Excel ID: ${clientsByExcelId.size}  
      - Nazwy: ${clientsByName.size}`);

    console.log(`üë• [Product Investors] Mapa klient√≥w: ${clientsMap.size} total, ${clientsByExcelId.size} z Excel ID`);

    // üìä KROK 3: Zbierz wszystkie inwestycje z r√≥≈ºnych kolekcji
    const allInvestments = [];

    // Helper do dodawania inwestycji z oznaczeniem kolekcji
    const addInvestments = (snapshot, collectionType) => {
      snapshot.docs.forEach(doc => {
        allInvestments.push({
          id: doc.id,
          collection_type: collectionType,
          ...doc.data(),
        });
      });
    };

    addInvestments(investmentsSnapshot, 'investments');
    addInvestments(bondsSnapshot, 'bonds');
    addInvestments(sharesSnapshot, 'shares');
    addInvestments(loansSnapshot, 'loans');
    addInvestments(apartmentsSnapshot, 'apartments');

    console.log(`üíº [Product Investors] ≈ÅƒÖcznie inwestycji: ${allInvestments.length}`);

    // üìä KROK 4: Filtrowanie inwestycji wed≈Çug strategii wyszukiwania
    let matchingInvestments = [];

    if (searchStrategy === 'exact' && productName) {
      // Strategia dok≈Çadnej nazwy
      matchingInvestments = allInvestments.filter(investment => {
        const investmentProductName = getInvestmentProductName(investment);
        return investmentProductName === productName;
      });
      console.log(`üéØ [Product Investors] Strategia dok≈Çadna: ${matchingInvestments.length} inwestycji`);

    } else if (searchStrategy === 'type' && productType) {
      // Strategia wed≈Çug typu produktu
      const typeVariants = getProductTypeVariants(productType);
      matchingInvestments = allInvestments.filter(investment => {
        const investmentType = getInvestmentProductType(investment);
        return typeVariants.some(variant =>
          investmentType.toLowerCase().includes(variant.toLowerCase())
        );
      });
      console.log(`üéØ [Product Investors] Strategia typ: ${matchingInvestments.length} inwestycji`);

    } else {
      // Strategia komprehensywna (domy≈õlna)
      matchingInvestments = findInvestmentsByComprehensiveSearch(
        allInvestments,
        productName,
        productType
      );
      console.log(`üéØ [Product Investors] Strategia komprehensywna: ${matchingInvestments.length} inwestycji`);
    }

    if (matchingInvestments.length === 0) {
      console.log("‚ö†Ô∏è [Product Investors] Brak pasujƒÖcych inwestycji");
      const emptyResult = {
        investors: [],
        totalCount: 0,
        searchStrategy: searchStrategy,
        productName: productName || '',
        productType: productType || '',
        executionTime: Date.now() - startTime,
        fromCache: false,
        debugInfo: {
          totalInvestments: allInvestments.length,
          totalClients: clientsMap.size,
          searchCriteria: { productName, productType, searchStrategy }
        }
      };

      // Cache pustego wyniku na kr√≥tko (1 minuta)
      await setCachedResult(cacheKey, emptyResult, 60);
      return emptyResult;
    }

    // üìä KROK 5: Grupowanie inwestycji wed≈Çug klient√≥w z ulepszonym mapowaniem
    console.log("üîÑ [Product Investors] Grupowanie wed≈Çug klient√≥w...");
    const investmentsByClient = new Map();
    let mappedInvestments = 0;
    let unmappedInvestments = 0;

    matchingInvestments.forEach(investment => {
      // Pobierz identyfikatory klienta z inwestycji
      const excelClientId = investment.clientId || investment.ID_Klient || investment.id_klient?.toString();
      const clientName = investment.clientName || investment.Klient || investment.klient;

      let resolvedClient = null;

      // Strategia 1: Mapowanie przez Excel ID
      if (excelClientId && clientsByExcelId.has(excelClientId)) {
        resolvedClient = clientsByExcelId.get(excelClientId);
        mappedInvestments++;
        console.log(`‚úÖ [Product Investors] Zmapowano przez Excel ID: ${excelClientId} -> ${resolvedClient.fullName || resolvedClient.imie_nazwisko || resolvedClient.name}`);
      }
      // Strategia 2: Mapowanie przez nazwƒô klienta (fallback)
      else if (clientName && clientsByName.has(clientName)) {
        resolvedClient = clientsByName.get(clientName);
        mappedInvestments++;
        console.log(`‚úÖ [Product Investors] Zmapowano przez nazwƒô: ${clientName}`);
      }
      // Strategia 3: Nie uda≈Ço siƒô zmapowaƒá - loguj problem
      else {
        unmappedInvestments++;
        if (!excelClientId && !clientName) {
          console.warn(`‚ö†Ô∏è [Product Investors] Inwestycja bez ID klienta: ${investment.id}`);
        } else {
          console.warn(`‚ùå [Product Investors] Nie znaleziono klienta o ID: ${excelClientId} lub nazwie: ${clientName}`);
        }
        return; // Pomi≈Ñ tƒô inwestycjƒô
      }

      // Dodaj inwestycjƒô do grupy klienta
      const clientKey = resolvedClient.id;
      if (!investmentsByClient.has(clientKey)) {
        investmentsByClient.set(clientKey, {
          client: resolvedClient,
          investments: []
        });
      }

      investmentsByClient.get(clientKey).investments.push({
        ...investment,
        resolvedClientId: resolvedClient.id,
        mappingMethod: excelClientId ? 'excelId' : 'name',
      });
    });

    console.log(`üìä [Product Investors] Statystyki mapowania:
      - Zmapowane inwestycje: ${mappedInvestments}
      - Niezmapowane inwestycje: ${unmappedInvestments}
      - Unikalnych klient√≥w: ${investmentsByClient.size}`);

    matchingInvestments.forEach(investment => {
      // Spr√≥buj r√≥≈ºne sposoby identyfikacji klienta
      const clientIdentifiers = extractClientIdentifiers(investment);
      let matchedClient = null;

      // Znajd≈∫ klienta wed≈Çug r√≥≈ºnych identyfikator√≥w
      for (const identifier of clientIdentifiers) {
        if (clientsByExcelId.has(identifier)) {
          matchedClient = clientsByExcelId.get(identifier);
          break;
        }
      }

      // Fallback - spr√≥buj znale≈∫ƒá po nazwie klienta
      if (!matchedClient) {
        const clientName = getInvestmentClientName(investment);
        if (clientName && clientName.trim()) {
          for (const [clientId, client] of clientsMap.entries()) {
            const clientDbName = client.imie_nazwisko || client.name || '';
            // Por√≥wnaj dok≈Çadnie lub podobnie (usuwajƒÖc bia≈Çe znaki)
            if (clientDbName.trim() === clientName.trim() ||
              clientDbName.toLowerCase().includes(clientName.toLowerCase()) ||
              clientName.toLowerCase().includes(clientDbName.toLowerCase())) {
              matchedClient = client;
              console.log(`‚úÖ [Product Investors] Dopasowano klienta po nazwie: "${clientName}" -> "${clientDbName}"`);
              break;
            }
          }
        }
      }

      if (matchedClient) {
        const clientKey = matchedClient.id;
        if (!investmentsByClient.has(clientKey)) {
          investmentsByClient.set(clientKey, {
            client: matchedClient,
            investments: []
          });
        }
        investmentsByClient.get(clientKey).investments.push(investment);
      } else {
        console.log(`‚ö†Ô∏è [Product Investors] Nie mo≈ºna dopasowaƒá klienta dla inwestycji: ${investment.id}`);
      }
    });

    console.log(`üë• [Product Investors] Pogrupowane dla ${investmentsByClient.size} klient√≥w`);

    // üìä KROK 6: Tworzenie podsumowa≈Ñ inwestor√≥w
    console.log("üìà [Product Investors] Tworzenie podsumowa≈Ñ...");
    const investors = [];

    for (const [clientId, clientData] of investmentsByClient.entries()) {
      const investorSummary = createProductInvestorSummary(
        clientData.client,
        clientData.investments
      );
      investors.push(investorSummary);
    }

    // üìä KROK 7: Sortowanie wed≈Çug warto≈õci inwestycji
    investors.sort((a, b) => b.viableRemainingCapital - a.viableRemainingCapital);

    // üìä KROK 8: Oblicz statystyki
    const totalCapital = investors.reduce((sum, inv) => sum + inv.viableRemainingCapital, 0);
    const totalInvestments = investors.reduce((sum, inv) => sum + inv.investmentCount, 0);
    const avgCapital = investors.length > 0 ? totalCapital / investors.length : 0;

    const result = {
      investors,
      totalCount: investors.length,
      statistics: {
        totalCapital,
        totalInvestments,
        averageCapital: avgCapital,
        activeInvestors: investors.filter(inv => inv.client.isActive !== false).length,
      },
      searchStrategy,
      productName: productName || '',
      productType: productType || '',
      executionTime: Date.now() - startTime,
      fromCache: false,
      debugInfo: {
        totalInvestmentsScanned: allInvestments.length,
        matchingInvestments: matchingInvestments.length,
        totalClients: clientsMap.size,
        investmentsByClientGroups: investmentsByClient.size,
      }
    };

    // üíæ Cache wynik√≥w na 5 minut
    await setCachedResult(cacheKey, result, 300);

    console.log(`‚úÖ [Product Investors] Zako≈Ñczone w ${result.executionTime}ms, zwracam ${investors.length} inwestor√≥w`);
    return result;

  } catch (error) {
    console.error("‚ùå [Product Investors] B≈ÇƒÖd:", {
      message: error.message,
      stack: error.stack,
      data: data,
      timestamp: new Date().toISOString()
    });

    throw new HttpsError(
      "internal",
      `B≈ÇƒÖd podczas pobierania inwestor√≥w produktu: ${error.message}`,
      {
        originalError: error.message,
        productName: data.productName,
        productType: data.productType,
        timestamp: new Date().toISOString()
      }
    );
  }
});

// üõ†Ô∏è HELPER FUNCTIONS

/**
 * WyciƒÖga nazwƒô produktu z inwestycji (mapowanie na rzeczywiste pola Firestore)
 */
function getInvestmentProductName(investment) {
  // U≈ºyj dok≈Çadnych nazw p√≥l z Firestore
  return investment.Produkt_nazwa || // G≈Ç√≥wne pole
    investment.nazwa_obligacji ||  // Dla obligacji
    investment.productName ||      // Backup angielski
    investment.name ||             // Og√≥lny backup
    '';
}

/**
 * WyciƒÖga typ produktu z inwestycji (mapowanie na rzeczywiste pola Firestore)
 */
function getInvestmentProductType(investment) {
  // U≈ºyj dok≈Çadnych nazw p√≥l z Firestore
  return investment.Typ_produktu ||    // G≈Ç√≥wne pole ("Obligacje")
    investment.productType ||     // Backup pole ("Obligacje")  
    investment.investment_type || // Angielska wersja ("bonds")
    investment.typ_produktu ||    // Lowercase backup
    investment.type ||            // Og√≥lny backup
    '';
}

/**
 * WyciƒÖga identyfikatory klienta z inwestycji (mapowanie na rzeczywiste pola Firestore)
 */
function extractClientIdentifiers(investment) {
  const identifiers = [];

  // G≈Ç√≥wne pola ID klienta zgodne z Firestore
  if (investment.ID_Klient) identifiers.push(investment.ID_Klient.toString());
  if (investment.clientId) identifiers.push(investment.clientId.toString());
  if (investment.id_klient) identifiers.push(investment.id_klient.toString());
  if (investment.klient_id) identifiers.push(investment.klient_id.toString());

  return identifiers.filter(id => id && id !== 'undefined' && id !== 'NULL');
}

/**
 * WyciƒÖga nazwƒô klienta z inwestycji (mapowanie na rzeczywiste pola Firestore)
 */
function getInvestmentClientName(investment) {
  // G≈Ç√≥wne pole nazwiska klienta w Firestore
  return investment.Klient ||      // G≈Ç√≥wne pole ("Piotr Gij")
    investment.klient ||      // Lowercase backup
    investment.clientName ||  // Angielski backup
    investment.client_name || // Snake case backup
    '';
}

/**
 * Zwraca warianty nazw typu produktu dla wyszukiwania
 */
function getProductTypeVariants(productType) {
  const variants = {
    'bonds': ['Obligacje', 'obligacje', 'Bond', 'Bonds'],
    'shares': ['Udzia≈Çy', 'udzia≈Çy', 'Share', 'Shares', 'Akcje', 'akcje'],
    'loans': ['Po≈ºyczki', 'po≈ºyczki', 'Loan', 'Loans', 'Pozyczki'],
    'apartments': ['Apartamenty', 'apartamenty', 'Apartment', 'Mieszkania'],
    'other': ['Inne', 'inne', 'Other', 'Pozosta≈Çe']
  };

  return variants[productType] || [productType];
}

/**
 * Komprehensywne wyszukiwanie inwestycji
 */
function findInvestmentsByComprehensiveSearch(allInvestments, productName, productType) {
  const matching = [];
  const searchTerms = [];

  // Przygotuj terminy wyszukiwania
  if (productName) {
    searchTerms.push(productName.toLowerCase());

    // Dodaj czƒô≈õci nazwy (dla apartament√≥w typu "Nazwa - Budynek A1")
    const parts = productName.split(/[-‚Äì‚Äî_\s]+/).filter(p => p.length > 2);
    searchTerms.push(...parts.map(p => p.toLowerCase()));
  }

  if (productType) {
    const typeVariants = getProductTypeVariants(productType);
    searchTerms.push(...typeVariants.map(v => v.toLowerCase()));
  }

  console.log(`üîç [Product Investors] Terminy wyszukiwania: ${searchTerms.join(', ')}`);

  allInvestments.forEach(investment => {
    const productNameInv = getInvestmentProductName(investment).toLowerCase();
    const productTypeInv = getInvestmentProductType(investment).toLowerCase();

    // Sprawd≈∫ czy kt√≥rykolwiek termin wystƒôpuje w nazwie lub typie produktu
    const matches = searchTerms.some(term =>
      productNameInv.includes(term) ||
      productTypeInv.includes(term) ||
      term.includes(productNameInv.split(/[-‚Äì‚Äî_\s]+/)[0]) // Sprawd≈∫ pierwsze s≈Çowo
    );

    if (matches) {
      matching.push(investment);
    }
  });

  return matching;
}

/**
 * Tworzy podsumowanie inwestora dla konkretnego produktu
 */
function createProductInvestorSummary(client, investments) {
  let totalViableCapital = 0;
  let totalInvestmentAmount = 0;
  let totalRealizedCapital = 0;

  const processedInvestments = investments.map(investment => {
    // Mapowanie kwoty inwestycji - sprawd≈∫ pola w kolejno≈õci priorytet√≥w - NOWE POLA MAJƒÑ WY≈ªSZY PRIORYTET
    const amount = parseFloat(
      investment.Kwota_inwestycji ||        // Nowe pole (string)
      investment.kwota_inwestycji ||        // Stare pole (number)
      investment.investmentAmount ||        // Backup pole (number)
      0
    );

    // Mapowanie kapita≈Çu pozosta≈Çego - obs≈Çu≈º r√≥≈ºne formaty - NOWE POLA MAJƒÑ WY≈ªSZY PRIORYTET
    let remainingCapital = 0;

    if (investment['Kapital Pozostaly']) {
      // String z przecinkami: "200,000.00"
      const cleaned = investment['Kapital Pozostaly'].toString().replace(/,/g, '');
      remainingCapital = parseFloat(cleaned) || 0;
    } else if (investment.kapital_pozostaly) {
      // Number pole
      remainingCapital = parseFloat(investment.kapital_pozostaly) || 0;
    } else if (investment.remainingCapital) {
      // Backup number pole  
      remainingCapital = parseFloat(investment.remainingCapital) || 0;
    } else if (investment.kapital_do_restrukturyzacji) {
      // Alternative number pole
      remainingCapital = parseFloat(investment.kapital_do_restrukturyzacji) || 0;
    }

    // Mapowanie zrealizowanego kapita≈Çu - NOWE POLA MAJƒÑ WY≈ªSZY PRIORYTET
    let realizedCapital = 0;

    if (investment['Kapital zrealizowany']) {
      // String pole: "0.00"
      const cleaned = investment['Kapital zrealizowany'].toString().replace(/,/g, '');
      realizedCapital = parseFloat(cleaned) || 0;
    } else if (investment.kapital_zrealizowany) {
      // Number pole
      realizedCapital = parseFloat(investment.kapital_zrealizowany) || 0;
    } else if (investment.realizedCapital) {
      // Backup number pole
      realizedCapital = parseFloat(investment.realizedCapital) || 0;
    }

    // Mapowanie dodatkowych p√≥l dla analiz
    const remainingInterest = parseFloat(investment.odsetki_pozostale || investment.remainingInterest || 0);
    const realizedInterest = parseFloat(investment.odsetki_zrealizowane || investment.realizedInterest || 0);
    const status = investment.Status_produktu || investment.status || 'Nieznany';

    totalInvestmentAmount += amount;
    totalViableCapital += remainingCapital;
    totalRealizedCapital += realizedCapital;

    return {
      id: investment.id,
      collection_type: investment.collection_type,
      // Podstawowe kwoty
      investmentAmount: amount,
      remainingCapital: remainingCapital,
      realizedCapital: realizedCapital,
      // Odsetki
      remainingInterest: remainingInterest,
      realizedInterest: realizedInterest,
      // Produkt info
      productName: getInvestmentProductName(investment),
      productType: getInvestmentProductType(investment),
      status: status,
      // Daty (konwersja string√≥w na daty)
      dataEmisji: convertFirestoreDate(investment.data_emisji),
      dataWykupu: convertFirestoreDate(investment.data_wykupu),
      dataPodpisania: convertFirestoreDate(investment.Data_podpisania),
      dataWejscia: convertFirestoreDate(investment.Data_wejscia_do_inwestycji),
      // Metadane
      idSprzedaz: investment.ID_Sprzedaz,
      oddzial: investment.Oddzial,
      opiekunMisa: investment['Opiekun z MISA'],
      // Raw data dla debugowania
      raw: investment
    };
  });

  // Mapuj status g≈Çosowania na podstawie danych klienta
  const mapVotingStatus = (status) => {
    if (!status) return 'undecided';
    const statusStr = status.toString().toLowerCase();

    if (statusStr.includes('tak') || statusStr === 'yes') return 'yes';
    if (statusStr.includes('nie') || statusStr === 'no') return 'no';
    if (statusStr.includes('wstrzymuj') || statusStr === 'abstain') return 'abstain';
    return 'undecided';
  };

  return {
    client: {
      id: client.id,
      name: client.imie_nazwisko || client.name || 'Nieznany klient',
      email: client.email || '',
      phone: client.telefon || client.phone || '',
      companyName: client.nazwa_firmy || client.companyName || null,
      isActive: client.isActive !== false,
      votingStatus: mapVotingStatus(client.votingStatus),
      // Dodatkowe pola klienta
      excelId: client.excelId || client.original_id,
      clientType: client.clientType || 'individual',
    },
    investments: processedInvestments,
    investmentCount: investments.length,
    totalInvestmentAmount,
    totalRealizedCapital,
    viableRemainingCapital: totalViableCapital,
    totalValue: totalViableCapital, // Dla kompatybilno≈õci z InvestorSummary
    // Dodatkowe metryki
    averageInvestment: investments.length > 0 ? totalViableCapital / investments.length : 0,
    hasMultipleInvestments: investments.length > 1,
    totalRemainingInterest: processedInvestments.reduce((sum, inv) => sum + inv.remainingInterest, 0),
    totalRealizedInterest: processedInvestments.reduce((sum, inv) => sum + inv.realizedInterest, 0),
    productSpecificData: {
      collections: [...new Set(investments.map(inv => inv.collection_type))],
      productTypes: [...new Set(investments.map(inv => getInvestmentProductType(inv)))],
      statuses: [...new Set(investments.map(inv => inv.Status_produktu || inv.status))],
      branches: [...new Set(investments.map(inv => inv.Oddzial).filter(Boolean))],
    }
  };
}

/**
 * Konwertuje r√≥≈ºne formaty dat z Firestore na Date object
 */
function convertFirestoreDate(dateValue) {
  if (!dateValue) return null;

  // Je≈õli to ju≈º Date object
  if (dateValue instanceof Date) return dateValue;

  // Je≈õli to Firestore Timestamp
  if (dateValue && typeof dateValue.toDate === 'function') {
    return dateValue.toDate();
  }

  // Je≈õli to string w formacie "2018-07-26 00:00:00" lub "7/31/18"
  if (typeof dateValue === 'string') {
    const parsed = new Date(dateValue);
    return isNaN(parsed.getTime()) ? null : parsed;
  }

  return null;
}

// üíæ CACHE FUNCTIONS (reuse from main index.js)
const cache = new Map();
const cacheTimestamps = new Map();

async function getCachedResult(key) {
  const timestamp = cacheTimestamps.get(key);
  if (!timestamp || Date.now() - timestamp > 300000) { // 5 minut
    cache.delete(key);
    cacheTimestamps.delete(key);
    return null;
  }
  return cache.get(key);
}

async function setCachedResult(key, data, ttlSeconds) {
  cache.set(key, data);
  cacheTimestamps.set(key, Date.now());

  setTimeout(() => {
    cache.delete(key);
    cacheTimestamps.delete(key);
  }, ttlSeconds * 1000);
}
